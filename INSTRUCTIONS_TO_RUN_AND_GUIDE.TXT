GENERAL
MAKE SURE TO MAKE YOUR OWN .env.development AND .env.production in both frontend and backend
open 2 consoles 1 for frontend 1 for backend

FRONTEND
Make sure you have nodejs
from root folder, cd frontend, npm install (do this everytime u want do in case someone installed new package), then npm run dev to run

BACKEND
from root folder, cd backend, pip install -r requirements.txt (do this everytime u want do in case someone installed new package), then python main.py to run

DATABASE
use your own mysql workbench local db then copy the link over to .env then run SCHEMA.sql on ur db, then if u wan dummy data preloaded run DUMMY_DATA.sql

DOCKER
tbc

HOW EVERYTHING WILL WORK TOGETHER
since we are developing now and not using cloud yet, we will have separate environment variables for development and production.
you should ownself create 2 env files in backend and frontend root folder respectively called .env.development and .env.production, the given .env.example you see is a list of all the env variables that we are using but the value u must fill urself.
when we are ready to test on docker (local), we will use docker-compose-dev-yml and slot in the .env.development inside the container, once we move to cloud use .env.production

At the end of the day, github actions (CICD) is the highest level of authority (i think) and once a code is pushed to main branch, it will be commanding our ec2 to run docker-compose on the prod yml
and running this docker-compose will run all our containers including db and security and run test cases, if all good then its launched
if anything goes wrong, it terminates and report back to github actions.



DOCUMENTATION FOR FRONTEND
/public folder store all media
/src/__tests__ is for test cases in frontend
/src/components/global is for components to be used across all pages
/src/components/* is the respective components for that specific page
/src/pages/* is the respective pages
/src/styles in case u wan use manual css add folders for each page here
/src/utils is repeated functions to be used throughout like rate limiting
/App.css dont touch
/App.jsx is the second level in the DOM for routing purposes and global states
/main.jsx is the first level which wraps around browser router
/const.js is for api routes
/Dockerfile is the dockerfile for react setup
To run tests run npm test

DOCUMENTATION FOR BACKEND
/tests contains all the tests for backend
/main.py is the highest level to run the flask App
/app/models contains the ORM models for your mysql tables which is mapped to SQLAlchemy
/app/routes contains your API routes, create own folder for auth or threads based API endpoints
/app/utils contains utility function
/app/db.py is just there so yan cong can draw for class diagram
/Dockerfile is the dockerfile for flask setup


DOCUMENTATION FOR NGINX
idk bruh this shit is gpt one but it acts as a proxy/load balancer? between fe communicating to be